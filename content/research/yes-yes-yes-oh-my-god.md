# 程序设计语言检查单 2024 版

## 本文的历史：
- [Colin McMillen, Jason Reed, Elly Fong-Jones 创作于 2011-10-10](https://www.mcmillen.dev/language_checklist.html)
- [BoppreH 改编于 2024-01-24](https://gist.github.com/boppreh/3b88231b7af15af54d292963f3d79b02)
- [CAIMEOX 作了一些补充修改](https://pl.caimeo.space/)
- Chuigda Whitegive 翻译于 2025-02

## 正文：

```
显然，你正在推广一种新的：
- 范式
  [ ] 函数式  [ ] 命令式  [ ] 面向对象  [ ] 过程式
  [ ] 基于栈  [ ] 逻辑式  [ ] 多范式
- 设计抉择
  [ ] 静态类型  [ ] 动态类型  [ ] 纯  [ ] 不纯
  [ ] 惰性求值  [ ] 急切求值
  [ ] 可共享的  [ ] 可证明  [ ] 图灵不完全
  [ ] 内存安全  [ ] 非内存安全
- 实现
  [ ] 解释型  [ ] 编译型  [ ] JIT
  [ ] 并行  [ ] 人工智能  [ ] 云原生
- 意图
  [ ] 学术型  [ ] 可视化  [ ] 初学者友好  [ ] 面向非程序员
  [ ] 怪异的  [ ] 完全无法理解的
的程序设计语言。洗洗睡吧孩子，因为：

显然，你寻思：
[ ] 程序语言的语法是编程主要的难点
[ ] 性能是：
    [ ] 无关紧要的  [ ] 至关重要的
    [ ] 和语言设计无关的
[ ] 垃圾回收是免费的
[ ] 计算机拥有无限的内存
[ ] 人工智能生成的代码基本是正确的  [ ] 并且不会吃上官司
[ ] 图灵完全的类型系统是一大优势
[ ] 开发者不会犯错，也不会臆测实现的行为
[ ] 没有人真的需要：
    [ ] 并发  [ ] REPL  [ ] 调试支持  [ ] IDE 支持  [ ] 输入输出
    [ ] 确定性  [ ] 编译期分析  [ ] 美好生活 [ ] 和其他语言的代码交互
[ ] 全世界都说 7 位 ASCII
[ ] 扩展到大型软件很简单
[ ] 劝说程序员使用一种新语言很简单
[ ] 劝说程序员使用一种专用 IDE 很简单
[ ] 程序员都喜欢写大量样板代码
[ ] 将行为标为“未定义”意味着程序员不会依赖它们
[ ] “超距作用”让编程更有趣
[ ] 编程语言的主要目标是写编译器

不幸的是，你的语言（具有/缺少）：
- 表层语法：
  [ ] 可以理解的语法  [ ] 有意义的空白  [ ] 分号  [ ] 赋值表达式
  [ ] 中缀运算符  [ ] 运算符重载  [ ] 嵌套注释  [ ] 多行字符串  [ ] 正则表达式
  [ ] 字符串模板  [ ] 管道  [ ] 变量遮蔽  [ ] emoji 变量名 [ ] 模式匹配与解构
  [ ] 符合人体工程学的错误值
- 语义：
  [ ] 闭包  [ ] 对象
  [ ] 传值调用  [ ] 传名调用  [ ] 传引用调用
  [ ] 内存安全  [ ] 借用检查
- 控制流：
  [ ] goto  [ ] comefrom 控制流，但缺乏讽刺性  [ ] 异步  [ ] 协程  [ ] 异常
  [ ] 类型和效应系统  [ ] 单子  [ ] 代数效应
  [ ] 尾递归  [ ] call/cc
- 类型系统：
  [ ] 隐式类型转换  [ ] 显式类型转换  [ ] 类型推断
  [ ] 不可变数据类型 [ ] 代数数据类型  [ ] 递归类型  [ ] 泛型类型
  [ ] 子类型  [ ] 类  [ ] 多重继承  [ ] 协变数组类型
  [ ] 依值类型  [ ] 渐进类型  [ ] 精化类型  [ ] 子结构类型
- 元编程：
  [ ] 卫生宏  [ ] 脏宏  [ ] DSL  [ ] 反射  [ ] 分阶段编程

就你语言的设计哲学而言，存在以下反对意见：
[ ] 程序员应该不必理解范畴论就能写出“你好世界”程序
[ ] 程序员不能在写完“你好世界”程序之后就罹患重复性劳损
[ ] 用你的语言编写的最大的程序就是这个语言的编译器
[ ] 用你的语言编写的最大的程序甚至不是这个语言的编译器
[ ] 没有语义规范
[ ] 语义规范没有经过形式验证
[ ] 实现即规范
    [ ] 实现是闭源的  [ ] 实现受专利保护  [ ] 实现不归你所有
[ ] 你的类型系统不健全
    [ ] 附有相关证明
    [ ] 调用此证明会导致编译器崩溃
[ ] 你的语言无法被无歧义地解析
[ ] 你的语言鼓励脆弱、不安全的程序
    [ ] 就连你的示例代码都没有好好处理边缘值
[ ] 你语言的名字
    [ ] 不可能在 Google 上找得到
    [ ] 读不出来
    [ ] 在 _________ 语里是脏话
[ ] 解释型语言永远不可能有 C 语言快
[ ] 编译型语言永远不会是“可扩展的”
[ ] 向后兼容和版本控制比你想象的更重要
[ ] 你的语言需要一种足够聪明的编译器
[ ] 地球上只有不到 100 个程序员聪明到可以使用你的语言
[ ] 单元测试 / 模糊测试对于开发编程语言来说完全足够了
[ ] ____________________________ 操作具有指数时间复杂度
[ ] ____________________________ 已知是不可判定（undecidable）的

你的语言实现具有以下缺陷：
[ ] 处理器不是这么工作的
[ ] 内存不是这么工作的
[ ] 虚拟机不是这么工作的
[ ] 编译器不是这么工作的
[ ] 编译器不可能这么工作
[ ] 解析过程中的移入规约冲突似乎是用 rand() 解决的
[ ] 你发现在运行时需要一个编译器
[ ] 你发现在编译时需要运行程序
[ ] 你的编译错误跟天书一样完全无法理解
[ ] 最基本的语言特性还在发展规划图上排队到了一年之后
[ ] 你语言的自述文件看起来像是人工智能生成的
[ ] 危险行为仅仅只有一个警告
[ ] 危险行为连警告都没有
[ ] 如果你用奇怪的眼神看着编译器，编译器就会崩溃
[ ] 如果你用奇怪的眼神看着虚拟机，虚拟机就会崩溃
[ ] 你的编译器用的大语言模型可以被越狱
[ ] 你似乎不理解基本的优化技术
[ ] 你似乎不理解基本的系统编程
[ ] 你似乎不理解指针
[ ] 你似乎不理解函数
[ ] 你似乎不太喜欢你的程序员同事

你的语言似乎面向以下市场：
[ ] 系统编程  [ ] 脚本编程  [ ] 壳 (shell) 程序  [ ] 网络  [ ] 游戏
[ ] 批处理任务  [ ] 制作应用程序  [ ] 编程教学
[ ] 安抚操作人员和安全人员  [ ] 恐吓操作人员和安全人员
[ ] 代码高尔夫  [ ] 戏仿语言  [ ] 书写类型论论文
[ ] 创造人工智能  [ ] *那个什么* 区块链 *如此如此这般这般*  [ ] 筹集风投资金的其他形式
但这个市场恐怕：
[ ] 已经是充满成熟方案的红海市场了
[ ] 不想接受来自小公司的解决方案
[ ] 不想接受来自个人兼职程序员的解决方案
[ ] 忙于处理“更重要的问题”
[ ] 太小了

此外，你在营销方面还遇到了如下问题：
[ ] 缺少代码示例
[ ] 这语言似乎并不能像你宣传的那样提升生产力
[ ] 这语言似乎并不能像你宣传的那样更“易用”
[ ] 声称的安全保证没有经过形式验证
[ ] 你在性能测试中作弊，因为实际上你是用这种方式完成操作的：
    [ ] 手写汇编
    [ ] 跨语言调用其他语言写好的库
[ ] 你乐于针对以下玩具功能进行基准测试：
    [ ] 加法  [ ] 斐波那契  [ ] FizzBuzz  [ ] JSON 解析  [ ] HTTP 伺服
[ ] 没有人认为你的语言能比这门语言快：
    [ ] 汇编  [ ] C  [ ] Rust  [ ] Go  [ ] Javascript  [ ] Python
[ ] 你毫无理由地拒绝正统程序设计语言理论
[ ] 你毫无理由地拒绝正统系统编程
[ ] 你毫无理由地拒绝正统算法理论
[ ] 你毫无理由地拒绝基本的计算机科学
[ ] 你毫无理由地拒绝工程伦理

我们的安全人员指出：
[ ] 你的构建：
    [ ] 无法复现  [ ] 没有签名  [ ] 杀软报毒
    [ ] 贴吧开源  [ ] 你国被制裁了
[ ] 它依赖外部服务器  [ ] 并且通过外部服务器执行代码  [ ] 甚至是在运行时
[ ] 你的反序列化功能与反向 shell 难以区分
[ ] 你的包管理器：
    [ ] 有安全漏洞
    [ ] 缺乏用户身份验证
    [ ] 完全没有吸取 left-pad 等软件包的教训

相比于类似的尝试，我得说：
[ ] 你复杂的示例代码在 _______________________ 语言里就一行代码的事：
    _____________________________________________________________________
[ ] 我们已经有很多“更好的 C 语言了”
[ ] 我们已经有很多安全的系统语言了
[ ] 我们已经有很多易学的语言了
[ ] 我们已经有很多用来写 Web 程序的语言了 —— 给前端用的，给后端用的，以及给全栈用的
[ ] 我们已经有很多安全的静态类型及早求值的语言了
[ ] 我们已经有很多“卧槽这玩意好几把酷”的语言了
[ ] 你重新发明了个更差的 Lisp
[ ] 你重新发明了个更差的 Haxe
[ ] 你重新发明了个更差的 Crystal
[ ] 你重新发明了个更差的 Zig
[ ] 你重新发明了个更差的 ECMAScript
[ ] 你重新发明了个更好的 ECMAScript，但这毫无意义
[ ] 你重新发明了 IntercalScript，但却没有 IntercalScript 的讽刺意味

总的来说，我觉得：
[ ] 你有很多有趣的想法，但你造的这玩意飞不起来
[ ] 垃圾语言，你应该为发明它而感到耻辱
[ ] 用这门语言编程就是对你发明它的惩罚
[ ] 当云服务的账单寄过来的时候，我不想跟你吴越同舟
```

另外两篇很有用的文章：
- [超市买菜](https://zhuanlan.zhihu.com/p/66349646)
- [DSL 的误区](https://yinwang-wiki.github.io/feeds/2017-05-25-dsl.html)
